I"É6<blockquote>
  <p>The browser is not a safe programming environment. It is
inherently insecure. ‚Äì Douglas Crockford, <a href="http://www.slideshare.net/webdirections/douglas-crockford-ajax-security-presentation">‚ÄúAjax Security‚Äù</a></p>
</blockquote>

<p>The web‚Äôs security model is fundamentally broken, and has been since the beginning. Browsers trust the code they receive from a website, so each chunk of JavaScript that executes on a page runs with access to the entire origin‚Äôs data. Cross-site scripting (XSS) attacks exploit this trust, injecting malicious code and other resources into a site in a wide variety of ways. At best, sites are defaced. At worst, user session data is compromised and leaked to untrusted third-parties.</p>

<p>It is, of course, possible to completely eliminate this class of attacks by properly escaping every bit of data that makes it onto a site. A brief glance back at the web‚Äôs history shows that this defense is unlikely to be effective; it‚Äôs simply a tough problem, given the convoluted set of escaping rules in various HTML contexts, differences in cross-browser implementation, and browser bugs (like <a href="http://en.wikipedia.org/wiki/UTF-7#security">UTF-7 support</a>). Even with our solid, modern understanding of the issue, and a variety of secure frameworks, it remains trivial to accidentally create a hole, and one hole is all it takes.</p>

<p>Content Security Policy (CSP) is a relatively new addition to the web platform that promises to mitigate the risk of XSS attacks by giving administrators fine-grained control over the data and code that ought to be allowed to run on their site. The feature boils down to a whitelisting mechanism for images, script, style, and a variety of other resource types. A site declares an acceptable list of origins for each data type it cares about via a straightforward HTTP header, and browsers that support the feature simply refuse to load resources that aren‚Äôt listed, thereby ensuring that user data can‚Äôt be leaked to third-parties. Browsers that don‚Äôt support the feature simply ignore the header, and proceed as per usual.</p>

<p>Though the feature is still very much bleeding-edge, implementations of <a href="https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html">the draft specification</a> exist in both Firefox 4+ and Chrome 16+, and the W3C has <a href="http://www.w3.org/2011/07/security-activity.html">proposed</a> a <a href="http://www.w3.org/2011/08/appsecwg-charter.html">Web Application Security Working Group</a> which includes CSP as a top-level deliverable. All that in mind, CSP is practically available right now, has no negative effects on browsers that don‚Äôt support it, and is already being used successfully by some pretty high-profile sites (like <a href="http://engineering.twitter.com/2011/03/improving-browser-security-with-csp.html">Twitter</a><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>). The implementations are being iterated upon, and things are still a bit fast and loose, but getting involved now is certainly something I‚Äôd recommend.</p>

<h2 id="mkwsts-policies">mkw.st‚Äôs Policies</h2>

<p>On <a href="https://mkw.st/">mkw.st</a>, I‚Äôm using one stylesheet hosted on <code class="highlighter-rouge">mkw.st</code>, one of Google‚Äôs web fonts, and a few inlined <code class="highlighter-rouge">data:</code> images. I‚Äôd like to ensure that that remains the case, and that I don‚Äôt accidentally load script from my friends at <code class="highlighter-rouge">evil.com</code>.</p>

<p>I‚Äôve configured my server to generate the following headers when loading the site:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -Ik https://mkw.st/
HTTP/1.1 200 OK
Server: nginx/1.0.8
Date: Sat, 08 Oct 2011 10:38:40 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 7940
Last-Modified: Sat, 08 Oct 2011 05:07:16 GMT
Connection: keep-alive
Vary: Accept-Encoding
Strict-Transport-Security: max-age=604800
X-WebKit-CSP: default-src 'self'; img-src 'self' data:; font-src https://themes.googleusercontent.com;
X-Content-Security-Policy: default-src 'self'; img-src 'self' data:; font-src https://themes.googleusercontent.com;
Accept-Ranges: bytes
</code></pre></div></div>

<p>The interesting bits are <code class="highlighter-rouge">X-Content-Security-Policy</code> and <code class="highlighter-rouge">X-WebKit-CSP</code><sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>, both of which contain a simple, semicolon-separated list of policy directives. Each directive consists of a type followed by a set of one or more ‚Äúsource expressions‚Äù that define the policy‚Äôs limitations. These expressions generally consist of scheme/host/port groupings, but can also contain wildcards and special keywords like <code class="highlighter-rouge">'self'</code> (which expands to the current site‚Äôs origin) and <code class="highlighter-rouge">'none'</code> (which ought to be self-explanatory). Let‚Äôs look at each in turn.</p>

<p>The first directive is of type <code class="highlighter-rouge">default-src</code>, which specifies a catch-all for content types that aren‚Äôt explicitly listed. I haven‚Äôt created a policy for objects (<code class="highlighter-rouge">object-src</code>), for example, so any request for video or Flash content would use the policy specified here. In this case, I‚Äôm specifying a single source: <code class="highlighter-rouge">'self'</code><sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. This means that resources that hit <code class="highlighter-rouge">default-src</code> can only be loaded from the same origin as the page itself. You may see references to <code class="highlighter-rouge">allow</code> in older CSP documentation: <code class="highlighter-rouge">default-src</code> replaces that keyword.</p>

<p>You likely won‚Äôt be shocked to learn that the next directive,<code class="highlighter-rouge">img-src</code>, whitelists sources for image resources. Here, images are limited to <code class="highlighter-rouge">data:</code> URLs, and to <code class="highlighter-rouge">'self'</code>.</p>

<p>Equally unsurprisingly, the directive of type <code class="highlighter-rouge">font-src</code> allows the site to load font resources from <code class="highlighter-rouge">https://themes.googleusercontent.com/</code>, which is taken quite literally and exclusively. Fonts can <em>only</em> be loaded from <code class="highlighter-rouge">themes.googleusercontent.com</code>, and <em>only</em> over HTTPS. Any request for a font from a different host or scheme would throw an error. It‚Äôs important to note here that the value of the <code class="highlighter-rouge">font-src</code> overrides <code class="highlighter-rouge">default-src</code> completely. They aren‚Äôt merged: I won‚Äôt be able to load fonts from <code class="highlighter-rouge">'self'</code> unless I explicitly add it to <code class="highlighter-rouge">font-src</code>‚Äôs definition.</p>

<h2 id="nothings-free">Nothing‚Äôs free.</h2>

<p>In order to function properly, Content Security Policy imposes a <a href="http://people.mozilla.com/~bsterne/content-security-policy/details.html#restrictions">few restrictions</a> on sites that make use of it. Two in particular are worth calling out here.</p>

<ol>
  <li>
    <p>CSP enforces a strict separation of behavior and semantics by refusing to execute inline script, and an equally strict separation of presentation and semantics by refusing to apply inline styles. This follows directly in line with the general recommendation of the web standards community, and allows CSP to clearly identify the source of each piece of data on a page. This identification is essential, as without it the whitelisting mechanism is ineffective. In addition, banning inline script and style substantially reduces the effect of cross-site scripting attacks that rely on JavaScript or CSS <a href="http://google-gruyere.appspot.com/part2#2__reflected_xss">reflection</a>: attackers will be forced to compromise a whitelisted resource, which is a much higher bar.</p>

    <p>It‚Äôs fairly obvious that this restriction will block execution of code contained within <code class="highlighter-rouge">&lt;script&gt;</code> blocks, but also note that it prevents event handlers from being written inline (<code class="highlighter-rouge">&lt;a ‚Ä¶ onclick="JAVASCRIPT"&gt;</code> ought to be rewritten to use <code class="highlighter-rouge">addEventListener(‚Ä¶)</code>). Likewise, <code class="highlighter-rouge">javascript:</code> URLs won‚Äôt work.</p>

    <p>It‚Äôs also the case that <code class="highlighter-rouge">data:</code> URLs are blocked by default, as they can contain arbitrary content that can‚Äôt be easily verified as being safe, or as really being intentionally written by your server. If you‚Äôd like to allow <code class="highlighter-rouge">data:</code> URLs, you‚Äôll have to do so on a type-by-type basis. See above, for example, where I‚Äôm explicitly allowing <code class="highlighter-rouge">data:</code> URLs for image resources, but not for any other resource type.</p>
  </li>
  <li>
    <p>Relatedly, raw strings will not be converted to code. This means that <code class="highlighter-rouge">eval</code> is right out, as are a variety of other <code class="highlighter-rouge">eval</code>-like mechanisms (<code class="highlighter-rouge">setTimeout</code> with a string argument, <code class="highlighter-rouge">new Function(‚Ä¶)</code>, and so on). Since <a href="http://www.jslint.com/lint.html#evil"><code class="highlighter-rouge">eval</code> is evil</a>, this isn‚Äôt a particularly onerous restriction, but it does mean that you‚Äôll need to parse JSON content without simply executing it, either with something like <a href="http://www.json.org/js.html">json.js</a> or with a built-in JSON object.</p>
  </li>
</ol>

<h2 id="further-reading">Further Reading</h2>

<p>After this introduction to the feature, I hope you‚Äôre interested enough to want to play around a bit with the headers on your own sites.</p>

<ul>
  <li>
    <p>Mozilla‚Äôs developer network has a <a href="https://developer.mozilla.org/en/Introducing_Content_Security_Policy">great series of articles</a> that go into a bit more depth, and outline features of CSP that I haven‚Äôt mentioned at all (<a href="https://developer.mozilla.org/en/Security/CSP/Using_CSP_violation_reports">violation reporting</a>, for instance).</p>
  </li>
  <li>
    <p>The list of resource types that Content Security Policy supports is extensive. This example touched on supports images, fonts, and objects, and <a href="https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#directives">a complete list can be found in the specification</a>. In general, the <a href="https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html">draft specification</a> is quite readable, and is the canonical resource for any question you might have.</p>
  </li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Though, since CSP is a bit broken in Chrome 15 and below, Twitter is only serving the header to Firefox (<a href="https://twitter.com/kurrik/status/123837358163496960">Hi, Arne!</a>):</p>

      <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ curl -I -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:7.0) Gecko/20100101 Firefox/7.0" mobile.twitter.com
HTTP/1.1 200 OK
Date: Tue, 11 Oct 2011 19:09:28 GMT
Server: hi
Status: 200 OK
ETag: "6f812aa05ca092e34fef322867230b3b"
X-Frame-Options: SAMEORIGIN
X-Content-Security-Policy: allow 'self'; img-src *.twitter.com *.twimg.com maps.google.com data:; media-src *.twitter.com *.twimg.com; style-src *.twitter.com *.twimg.com; frame-ancestors *.twitter.com; script-src *.twitter.com *.twimg.com api-secure.recaptcha.net; report-uri http://mobile.twitter.com/csp_violation_report
Content-Language: en
Content-Type: text/html; charset=utf-8
X-Runtime: 6
X-XSS-Protection: 1; mode=block
Content-Length: 3226
Pragma: no-cache
Expires: Mon, 01 Jan 1990 00:00:00 GMT
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Set-Cookie: k=92.230.68.58.1318360167849178; path=/; expires=Tue, 18-Oct-11 19:09:27 GMT; domain=.twitter.com
Set-Cookie: _mobile_sess=BAh7BzoQX2NzcmZfdG9rZW4iGTI4ODY1MDBjZTMxMTFjZmMyOTNmOg9zZXNzaW9uX2lkIiUwYTEwNjE1YjlkNDkzZmFiYzRhMWM4NWI3NTkyNGVhMg%3D%3D--a55f94a4b138aca8618b0bfbaf45bbe96f61450b; path=/; expires=Mon, 05-Dec-2011 22:22:00 GMT
Vary: Accept-Encoding
Connection: close
</code></pre></div>      </div>
      <p><a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Firefox is <a href="http://blog.mozilla.com/security/2011/03/22/creating-a-safer-web-with-content-security-policy/">confident enough</a> in the draft spec to use the canonical header, WebKit (and therefore Chrome) are a little more cautious, and have prefixed the header just in case: the details are the same. Both teams are working from the same spec, and both are pretty much feature complete. To follow their progress, CC yourself on either <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=663566">Bugzilla #663566</a>, or <a href="https://bugs.webkit.org/show_bug.cgi?id=53572">WebKit #53572</a>.¬†<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Note the single-quotes around <code class="highlighter-rouge">'self'</code> and <code class="highlighter-rouge">'none'</code>. These are required. Without them, the policy would refer to a server with a hostname of <code class="highlighter-rouge">self</code> or <code class="highlighter-rouge">none</code>, which almost certainly isn‚Äôt what you mean.¬†<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET